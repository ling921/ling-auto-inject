using VerifyCS = Ling.AutoInject.SourceGenerators.Tests.Verifiers.CSharpSourceGeneratorVerifier<
    Ling.AutoInject.SourceGenerators.AutoInjectGenerator>;

namespace Ling.AutoInject.SourceGenerators.Tests;

public class AutoInjectGeneratorTests
{
    private static async Task VerifyGeneratedCodeAsync(string source, string expectedGeneratedCode)
    {
        await VerifyCS.VerifySourceGeneratorAsync(
            source,
            ("AutoInjectConfigAttribute.g.cs", SourceCodes.AutoInjectConfigAttribute),
            ("AutoInjectExtensionsAttribute.g.cs", SourceCodes.AutoInjectExtensionsAttribute),
            ("SingletonServiceAttribute.g.cs", SourceCodes.SingletonServiceAttribute),
            ("ScopedServiceAttribute.g.cs", SourceCodes.ScopedServiceAttribute),
            ("TransientServiceAttribute.g.cs", SourceCodes.TransientServiceAttribute),
            ("AutoInject_TestProject.g.cs", expectedGeneratedCode));
    }

    private static async Task VerifyGeneratedCodeAsync(
        string source,
        string? expectedSingletonServices,
        string? expectedScopedServices,
        string? expectedTransientServices)
    {
        static string IndentServiceLines(string? serviceLines) => string.IsNullOrWhiteSpace(serviceLines)
                ? string.Empty
                : string.Concat(serviceLines.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None).Select(line => Environment.NewLine + "            " + line.Trim()));

        var singletonServicesBody = IndentServiceLines(expectedSingletonServices);
        var scopedServicesBody = IndentServiceLines(expectedScopedServices);
        var transientServicesBody = IndentServiceLines(expectedTransientServices);

        var generatedCode = $$"""
            // <auto-generated />
            
            #pragma warning disable
            #nullable enable annotations

            using Microsoft.Extensions.DependencyInjection;
            using Microsoft.Extensions.DependencyInjection.Extensions;

            namespace TestProject
            {
                /// <summary>
                /// Auto-generated extension methods for registering services with AutoInject attributes.
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Ling.AutoInject.SourceGenerators", "{{Constants.Version}}")]
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                public static partial class TestProject_AutoInjectGenerated
                {
                    /// <summary>
                    /// Adds services decorated with AutoInject attributes from the assembly 'TestProject' to the IServiceCollection.
                    /// <para>
                    /// Implements the 'AddAdditionalServices' partial method to further customize service registrations.
                    /// </para>
                    /// </summary>
                    /// <param name="services">The IServiceCollection to add services to.</param>
                    /// <returns>The IServiceCollection for chaining.</returns>
                    public static IServiceCollection AddTestProjectServices(this IServiceCollection services)
                    {
                        if (services == null) throw new ArgumentNullException(nameof(services));

                        AddSingletonServices(services);
                        AddScopedServices(services);
                        AddTransientServices(services);
                        AddAdditionalServices(services);

                        return services;
                    }

                    private static void AddSingletonServices(IServiceCollection services)
                    {{{singletonServicesBody}}
                    }

                    private static void AddScopedServices(IServiceCollection services)
                    {{{scopedServicesBody}}
                    }
 
                    private static void AddTransientServices(IServiceCollection services)
                    {{{transientServicesBody}}
                    }

                    /// <summary>
                    /// Adds additional services to the container.
                    /// </summary>
                    /// <param name="services">The service collection.</param>
                    static partial void AddAdditionalServices(IServiceCollection services);
                }
            }

            """;

        await VerifyCS.VerifySourceGeneratorAsync(
            source,
            ("AutoInjectConfigAttribute.g.cs", SourceCodes.AutoInjectConfigAttribute),
            ("AutoInjectExtensionsAttribute.g.cs", SourceCodes.AutoInjectExtensionsAttribute),
            ("SingletonServiceAttribute.g.cs", SourceCodes.SingletonServiceAttribute),
            ("ScopedServiceAttribute.g.cs", SourceCodes.ScopedServiceAttribute),
            ("TransientServiceAttribute.g.cs", SourceCodes.TransientServiceAttribute),
            ("AutoInject_TestProject.g.cs", generatedCode));
    }

    [Fact]
    public async Task AutoInjectGenerator_WithCustomMethod_GeneratesExtensionClass()
    {
        const string source = """
            [assembly: Ling.AutoInject.AutoInjectConfig(MethodName = "AddCustomServices", ClassName = "ServiceExtensions", Namespace = "MyNamespace")]
            """;
        var generatedCode = $$"""
            // <auto-generated />
            
            #pragma warning disable
            #nullable enable annotations

            using Microsoft.Extensions.DependencyInjection;
            using Microsoft.Extensions.DependencyInjection.Extensions;

            namespace MyNamespace
            {
                /// <summary>
                /// Auto-generated extension methods for registering services with AutoInject attributes.
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Ling.AutoInject.SourceGenerators", "{{Constants.Version}}")]
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                public static partial class ServiceExtensions
                {
                    /// <summary>
                    /// Adds services decorated with AutoInject attributes from the assembly 'TestProject' to the IServiceCollection.
                    /// <para>
                    /// Implements the 'AddAdditionalServices' partial method to further customize service registrations.
                    /// </para>
                    /// </summary>
                    /// <param name="services">The IServiceCollection to add services to.</param>
                    /// <returns>The IServiceCollection for chaining.</returns>
                    public static IServiceCollection AddCustomServices(this IServiceCollection services)
                    {
                        if (services == null) throw new ArgumentNullException(nameof(services));

                        AddSingletonServices(services);
                        AddScopedServices(services);
                        AddTransientServices(services);
                        AddAdditionalServices(services);

                        return services;
                    }

                    private static void AddSingletonServices(IServiceCollection services)
                    {
                    }
 
                    private static void AddScopedServices(IServiceCollection services)
                    {
                    }
 
                    private static void AddTransientServices(IServiceCollection services)
                    {
                    }

                    /// <summary>
                    /// Adds additional services to the container.
                    /// </summary>
                    /// <param name="services">The service collection.</param>
                    static partial void AddAdditionalServices(IServiceCollection services);
                }
            }

            """;
        await VerifyGeneratedCodeAsync(source, generatedCode);
    }

    [Fact]
    public async Task AutoInjectGenerator_WithPartialClass_GeneratesExtensionClass()
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                [AutoInjectExtensions(MethodName = "AddCustomServices")]
                public static partial class MyServiceExtensions { }
            }
            """;

        var generatedCode = $$"""
            // <auto-generated />
            
            #pragma warning disable
            #nullable enable annotations

            using Microsoft.Extensions.DependencyInjection;
            using Microsoft.Extensions.DependencyInjection.Extensions;

            namespace Test
            {
                /// <summary>
                /// Auto-generated extension methods for registering services with AutoInject attributes.
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Ling.AutoInject.SourceGenerators", "{{Constants.Version}}")]
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                static partial class MyServiceExtensions
                {
                    /// <summary>
                    /// Adds services decorated with AutoInject attributes from the assembly 'TestProject' to the IServiceCollection.
                    /// <para>
                    /// Implements the 'AddAdditionalServices' partial method to further customize service registrations.
                    /// </para>
                    /// </summary>
                    /// <param name="services">The IServiceCollection to add services to.</param>
                    /// <returns>The IServiceCollection for chaining.</returns>
                    public static IServiceCollection AddCustomServices(this IServiceCollection services)
                    {
                        if (services == null) throw new ArgumentNullException(nameof(services));

                        AddSingletonServices(services);
                        AddScopedServices(services);
                        AddTransientServices(services);
                        AddAdditionalServices(services);

                        return services;
                    }

                    private static void AddSingletonServices(IServiceCollection services)
                    {
                    }
 
                    private static void AddScopedServices(IServiceCollection services)
                    {
                    }
 
                    private static void AddTransientServices(IServiceCollection services)
                    {
                    }

                    /// <summary>
                    /// Adds additional services to the container.
                    /// </summary>
                    /// <param name="services">The service collection.</param>
                    static partial void AddAdditionalServices(IServiceCollection services);
                }
            }

            """;
        await VerifyGeneratedCodeAsync(source, generatedCode);
    }

    [Fact]
    public async Task AutoInjectGenerator_WithPartialClassAnd_GeneratesExtensionClass()
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                [AutoInjectExtensions(MethodName = "AddCustomServices", IncludeConfiguration = true)]
                public static partial class MyServiceExtensions { }
            }
            """;

        var generatedCode = $$"""
            // <auto-generated />
            
            #pragma warning disable
            #nullable enable annotations

            using Microsoft.Extensions.DependencyInjection;
            using Microsoft.Extensions.DependencyInjection.Extensions;

            namespace Test
            {
                /// <summary>
                /// Auto-generated extension methods for registering services with AutoInject attributes.
                /// </summary>
                [global::System.CodeDom.Compiler.GeneratedCode("Ling.AutoInject.SourceGenerators", "{{Constants.Version}}")]
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                static partial class MyServiceExtensions
                {
                    /// <summary>
                    /// Adds services decorated with AutoInject attributes from the assembly 'TestProject' to the IServiceCollection.
                    /// <para>
                    /// Implements the 'AddAdditionalServices' partial method to further customize service registrations.
                    /// </para>
                    /// </summary>
                    /// <param name="services">The IServiceCollection to add services to.</param>
                    /// <param name="configuration">The configuration.</param>
                    /// <returns>The IServiceCollection for chaining.</returns>
                    public static IServiceCollection AddCustomServices(this IServiceCollection services, global::Microsoft.Extensions.Configuration.Abstractions.IConfiguration configuration)
                    {
                        if (services == null) throw new ArgumentNullException(nameof(services));

                        AddSingletonServices(services);
                        AddScopedServices(services);
                        AddTransientServices(services);
                        AddAdditionalServices(services, configuration);

                        return services;
                    }

                    private static void AddSingletonServices(IServiceCollection services)
                    {
                    }
 
                    private static void AddScopedServices(IServiceCollection services)
                    {
                    }
 
                    private static void AddTransientServices(IServiceCollection services)
                    {
                    }

                    /// <summary>
                    /// Adds additional services to the container.
                    /// </summary>
                    /// <param name="services">The service collection.</param>
                    /// <param name="configuration">The configuration.</param>
                    static partial void AddAdditionalServices(IServiceCollection services, global::Microsoft.Extensions.Configuration.Abstractions.IConfiguration configuration);
                }
            }

            """;
        await VerifyGeneratedCodeAsync(source, generatedCode);
    }

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_SingleService_NoServiceType_GeneratesRegistration(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                [{{lifetime}}Service]
                public class MyService
                {
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
            ? "services.TryAddSingleton<global::Test.MyService>();"
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
            ? "services.TryAddScoped<global::Test.MyService>();"
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
            ? "services.TryAddTransient<global::Test.MyService>();"
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_SingleService_WithServiceType_GeneratesRegistration(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                public interface IFoo { }

                [{{lifetime}}Service(typeof(IFoo))]
                public class MyService : IFoo
                {
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
            ? "services.TryAddSingleton<global::Test.IFoo, global::Test.MyService>();"
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
            ? "services.TryAddScoped<global::Test.IFoo, global::Test.MyService>();"
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
            ? "services.TryAddTransient<global::Test.IFoo, global::Test.MyService>();"
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_SelfAndTyped_BothSpecified_GeneratesBothRegistrations(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                public interface IFoo { }

                [{{lifetime}}Service]
                [{{lifetime}}Service(typeof(IFoo))]
                public class MyService : IFoo
                {
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
            ? """
              services.TryAddSingleton<global::Test.MyService>();
              services.TryAddSingleton<global::Test.IFoo>(sp => (global::Test.IFoo)sp.GetRequiredService<global::Test.MyService>());
              """
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
            ? """
              services.TryAddScoped<global::Test.MyService>();
              services.TryAddScoped<global::Test.IFoo>(sp => (global::Test.IFoo)sp.GetRequiredService<global::Test.MyService>());
              """
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
            ? """
              services.TryAddTransient<global::Test.MyService>();
              services.TryAddTransient<global::Test.IFoo>(sp => (global::Test.IFoo)sp.GetRequiredService<global::Test.MyService>());
              """
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_MultipleAttributes_GeneratesImplementationRegistrations(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                public interface IFoo { }
                public interface IBar { }

                [{{lifetime}}Service(typeof(IFoo))]
                [{{lifetime}}Service(typeof(IBar))]
                public class MyService : IFoo, IBar
                {
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
            ? """
              services.TryAddSingleton<global::Test.IFoo, global::Test.MyService>();
              services.TryAddSingleton<global::Test.IBar>(sp => (global::Test.IBar)sp.GetRequiredService<global::Test.IFoo>());
              """
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
            ? """
              services.TryAddScoped<global::Test.IFoo, global::Test.MyService>();
              services.TryAddScoped<global::Test.IBar>(sp => (global::Test.IBar)sp.GetRequiredService<global::Test.IFoo>());
              """
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
            ? """
              services.TryAddTransient<global::Test.IFoo, global::Test.MyService>();
              services.TryAddTransient<global::Test.IBar>(sp => (global::Test.IBar)sp.GetRequiredService<global::Test.IFoo>());
              """
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_NamedServiceType_GeneratesTypedRegistration(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                public interface IFoo { }

                [{{lifetime}}Service(serviceType: typeof(IFoo))]
                public class MyService : IFoo
                {
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
            ? "services.TryAddSingleton<global::Test.IFoo, global::Test.MyService>();"
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
            ? "services.TryAddScoped<global::Test.IFoo, global::Test.MyService>();"
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
            ? "services.TryAddTransient<global::Test.IFoo, global::Test.MyService>();"
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    #region Keyed Services

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_KeyedSingleService_NoServiceType_GeneratesRegistration(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                [{{lifetime}}Service(ServiceKey = "k1")]
                public class MyService
                {
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
#if NET8_0_OR_GREATER
            ? """services.TryAddKeyedSingleton<global::Test.MyService>("k1");"""
#else
            ? "services.TryAddSingleton<global::Test.MyService>();"
#endif
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
#if NET8_0_OR_GREATER
            ? """services.TryAddKeyedScoped<global::Test.MyService>("k1");"""
#else
            ? "services.TryAddScoped<global::Test.MyService>();"
#endif
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
#if NET8_0_OR_GREATER
            ? """services.TryAddKeyedTransient<global::Test.MyService>("k1");"""
#else
            ? "services.TryAddTransient<global::Test.MyService>();"
#endif
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_KeyedSingleService_WithServiceType_GeneratesRegistration(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                public interface IFoo { }

                [{{lifetime}}Service(typeof(IFoo), ServiceKey = 1)]
                public class MyService : IFoo
                {
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
#if NET8_0_OR_GREATER
            ? "services.TryAddKeyedSingleton<global::Test.IFoo, global::Test.MyService>(1);"
#else
            ? "services.TryAddSingleton<global::Test.IFoo, global::Test.MyService>();"
#endif
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
#if NET8_0_OR_GREATER
            ? "services.TryAddKeyedScoped<global::Test.IFoo, global::Test.MyService>(1);"
#else
            ? "services.TryAddScoped<global::Test.IFoo, global::Test.MyService>();"
#endif
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
#if NET8_0_OR_GREATER
            ? "services.TryAddKeyedTransient<global::Test.IFoo, global::Test.MyService>(1);"
#else
            ? "services.TryAddTransient<global::Test.IFoo, global::Test.MyService>();"
#endif
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    [Theory]
    [InlineData("Singleton")]
    [InlineData("Scoped")]
    [InlineData("Transient")]
    public async Task AutoInjectGenerator_Keyed_SelfAndTyped_BothSpecified_GeneratesRegistrations(string lifetime)
    {
        var source = $$"""
            using Ling.AutoInject;

            namespace Test
            {
                public interface IFoo { }

                [{{lifetime}}Service(ServiceKey = MyService.Key)]
                [{{lifetime}}Service(typeof(IFoo), ServiceKey = MyService.Key)]
                public class MyService : IFoo
                {
                    public const string Key = "my-key";
                }
            }
            """;

        var expectedSingletonServices = lifetime == "Singleton"
#if NET8_0_OR_GREATER
            ? """
              services.TryAddKeyedSingleton<global::Test.MyService>("my-key");
              services.TryAddKeyedSingleton<global::Test.IFoo>("my-key", (sp, key) => (global::Test.IFoo)sp.GetRequiredKeyedService<global::Test.MyService>(key));
              """
#else
            ? """
              services.TryAddSingleton<global::Test.MyService>();
              services.TryAddSingleton<global::Test.IFoo>(sp => (global::Test.IFoo)sp.GetRequiredService<global::Test.MyService>());
              """
#endif
            : string.Empty;
        var expectedScopedServices = lifetime == "Scoped"
#if NET8_0_OR_GREATER
            ? """
              services.TryAddKeyedScoped<global::Test.MyService>("my-key");
              services.TryAddKeyedScoped<global::Test.IFoo>("my-key", (sp, key) => (global::Test.IFoo)sp.GetRequiredKeyedService<global::Test.MyService>(key));
              """
#else
            ? """
              services.TryAddScoped<global::Test.MyService>();
              services.TryAddScoped<global::Test.IFoo>(sp => (global::Test.IFoo)sp.GetRequiredService<global::Test.MyService>());
              """
#endif
            : string.Empty;
        var expectedTransientServices = lifetime == "Transient"
#if NET8_0_OR_GREATER
            ? """
              services.TryAddKeyedTransient<global::Test.MyService>("my-key");
              services.TryAddKeyedTransient<global::Test.IFoo>("my-key", (sp, key) => (global::Test.IFoo)sp.GetRequiredKeyedService<global::Test.MyService>(key));
              """
#else
            ? """
              services.TryAddTransient<global::Test.MyService>();
              services.TryAddTransient<global::Test.IFoo>(sp => (global::Test.IFoo)sp.GetRequiredService<global::Test.MyService>());
              """
#endif
            : string.Empty;

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    [Fact]
    public async Task AutoInjectGenerator_KeyedTypedServices_AllLifetimes_GeneratesRegistrations()
    {
        const string source = """
            using Ling.AutoInject;

            namespace Test
            {
                public interface IFoo { }
                public interface IBar { }
                public interface IBaz { }

                [SingletonService(ServiceKey = 1)]
                [SingletonService(typeof(IFoo), ServiceKey = 1)]
                public class FooService : IFoo { }

                [ScopedService(ServiceKey = "k1")]
                [ScopedService(typeof(IBar), ServiceKey = "k2")]
                public class BarService : IBar { }

                [TransientService(typeof(IBaz), ServiceKey = 1.1)]
                [TransientService(typeof(IBaz), ServiceKey = 1.2)]
                public class BazService : IBaz { }
            }
            """;

        var expectedSingletonServices =
#if NET8_0_OR_GREATER
            """
            services.TryAddKeyedSingleton<global::Test.FooService>(1);
            services.TryAddKeyedSingleton<global::Test.IFoo>(1, (sp, key) => (global::Test.IFoo)sp.GetRequiredKeyedService<global::Test.FooService>(key));
            """;
#else
            """
            services.TryAddSingleton<global::Test.FooService>();
            services.TryAddSingleton<global::Test.IFoo>(sp => (global::Test.IFoo)sp.GetRequiredService<global::Test.FooService>());
            """;
#endif
        var expectedScopedServices =
#if NET8_0_OR_GREATER
            """
            services.TryAddKeyedScoped<global::Test.BarService>("k1");
            services.TryAddKeyedScoped<global::Test.IBar, global::Test.BarService>("k2");
            """;
#else
            """
            services.TryAddScoped<global::Test.BarService>();
            services.TryAddScoped<global::Test.IBar>(sp => (global::Test.IBar)sp.GetRequiredService<global::Test.BarService>());
            """;
#endif
        var expectedTransientServices =
#if NET8_0_OR_GREATER
            """
            services.TryAddKeyedTransient<global::Test.IBaz, global::Test.BazService>(1.1);
            services.TryAddKeyedTransient<global::Test.IBaz, global::Test.BazService>(1.2);
            """;
#else
            """
            services.TryAddTransient<global::Test.IBaz, global::Test.BazService>();
            """;
#endif

        await VerifyGeneratedCodeAsync(
            source,
            expectedSingletonServices,
            expectedScopedServices,
            expectedTransientServices
        );
    }

    #endregion Keyed Services
}
